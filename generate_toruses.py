"""
Utility script to generate a collection of torus meshes with varying aspect
ratios and export them as Wavefront OBJ files.
"""

from __future__ import annotations

import argparse
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Sequence


def format_float(value: float, decimals: int = 4) -> str:
    """Format a float for filenames and directory names."""
    formatted = f"{value:.{decimals}f}".rstrip("0").rstrip(".")
    return formatted if formatted else "0"


@dataclass(frozen=True)
class TorusSpec:
    """Describes a single torus to export."""

    aspect_ratio: float
    major_radius: float = 1.0
    segments_major: int = 128
    segments_minor: int = 64
    elongation: float = 2.0  # stretch along the minor (z) axis

    @property
    def minor_radius(self) -> float:
        return self.major_radius / self.aspect_ratio

    @property
    def filename(self) -> str:
        formatted = format_float(self.aspect_ratio, decimals=2).replace(".", "_")
        return f"torus_aspect_{formatted}.obj"


def generate_vertices(spec: TorusSpec) -> Iterable[tuple[float, float, float]]:
    """Yield torus vertices for the provided specification."""
    for i in range(spec.segments_major):
        theta = 2.0 * math.pi * i / spec.segments_major
        cos_theta = math.cos(theta)
        sin_theta = math.sin(theta)

        for j in range(spec.segments_minor):
            phi = 2.0 * math.pi * j / spec.segments_minor
            cos_phi = math.cos(phi)
            sin_phi = math.sin(phi)
            radius = spec.major_radius + spec.minor_radius * cos_phi
            x = radius * cos_theta
            y = radius * sin_theta
            z = spec.minor_radius * sin_phi * spec.elongation
            yield x, y, z


def generate_faces(spec: TorusSpec) -> Iterable[tuple[int, int, int]]:
    """Yield triangle indices (1-based) for the torus surface mesh."""
    verts_per_loop = spec.segments_minor

    def vertex_index(loop: int, ring: int) -> int:
        return loop * verts_per_loop + ring + 1  # OBJ indices start at 1

    for i in range(spec.segments_major):
        i_next = (i + 1) % spec.segments_major
        for j in range(spec.segments_minor):
            j_next = (j + 1) % spec.segments_minor

            v1 = vertex_index(i, j)
            v2 = vertex_index(i_next, j)
            v3 = vertex_index(i_next, j_next)
            v4 = vertex_index(i, j_next)

            yield (v1, v2, v3)
            yield (v1, v3, v4)


def write_obj(path: Path, spec: TorusSpec) -> None:
    """Write a torus mesh to `path`."""
    with path.open("w", encoding="ascii") as obj_file:
        obj_file.write("# Torus OBJ generated by generate_toruses.py\n")
        obj_file.write(f"# Aspect ratio (R/r): {spec.aspect_ratio}\n")
        obj_file.write(f"# Major radius R = {spec.major_radius}\n")
        obj_file.write(f"# Minor radius r = {spec.minor_radius}\n")
        obj_file.write(f"# Elongation factor (z-scale) = {spec.elongation}\n")
        obj_file.write("\n")

        for x, y, z in generate_vertices(spec):
            obj_file.write(f"v {x:.6f} {y:.6f} {z:.6f}\n")

        obj_file.write("\n")

        for tri in generate_faces(spec):
            obj_file.write(f"f {tri[0]} {tri[1]} {tri[2]}\n")


def parse_args() -> argparse.Namespace:
    repo_root = Path(__file__).resolve().parent
    parser = argparse.ArgumentParser(
        description="Generate torus meshes for multiple aspect ratios and elongations."
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=repo_root / "toruses",
        help="Directory where torus meshes will be written.",
    )
    parser.add_argument(
        "--aspect-ratios",
        type=float,
        nargs="+",
        default=(1.1, 1.25, 1.5, 2.0, 3.0, 4.0, 6.0),
        help="Aspect ratios R/r to generate.",
    )
    parser.add_argument(
        "--elongations",
        type=float,
        nargs="+",
        default=(1.0, 1.5, 2.0, 3.0),
        help="Elongation factors (z-scale multipliers) to apply.",
    )
    parser.add_argument(
        "--segments-major",
        type=int,
        default=128,
        help="Number of samples around the major circle.",
    )
    parser.add_argument(
        "--segments-minor",
        type=int,
        default=64,
        help="Number of samples around the minor circle.",
    )
    parser.add_argument(
        "--major-radius",
        type=float,
        default=1.0,
        help="Major radius R of the torus.",
    )
    return parser.parse_args()


def generate_for_elongation(
    elongation: float,
    output_dir: Path,
    aspect_ratios: Sequence[float],
    segments_major: int,
    segments_minor: int,
    major_radius: float,
) -> None:
    elong_dir = output_dir / f"elongation_{format_float(elongation, decimals=2).replace('.', '_')}"
    elong_dir.mkdir(parents=True, exist_ok=True)

    for ratio in aspect_ratios:
        spec = TorusSpec(
            aspect_ratio=ratio,
            major_radius=major_radius,
            segments_major=segments_major,
            segments_minor=segments_minor,
            elongation=elongation,
        )
        destination = elong_dir / spec.filename
        write_obj(destination, spec)
        print(f"Wrote {destination}")


def main() -> None:
    """Create torus directories and export meshes for multiple elongations."""
    args = parse_args()
    args.output_dir.mkdir(parents=True, exist_ok=True)

    for elongation in args.elongations:
        generate_for_elongation(
            elongation=elongation,
            output_dir=args.output_dir,
            aspect_ratios=args.aspect_ratios,
            segments_major=args.segments_major,
            segments_minor=args.segments_minor,
            major_radius=args.major_radius,
        )


if __name__ == "__main__":
    main()

